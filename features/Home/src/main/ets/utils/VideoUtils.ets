import { VideoItem } from '../model/VideoModel'
import { VideoPlayState } from '../viewModel/VideoPlayerViewModel'
import { VideoConstants } from '../constants/VideoConstants'

// è§†é¢‘æ’­æ”¾å™¨å·¥å…·ç±»
export class VideoUtils {
  /**
   * éªŒè¯è§†é¢‘URLæ˜¯å¦æœ‰æ•ˆ
   */
  static isValidVideoUrl(url: string): boolean {
    if (!url || typeof url !== 'string') {
      return false
    }

    // ç®€å•çš„URLæ ¼å¼éªŒè¯
    const urlPattern = /^https?:\/\/.+/i
    return urlPattern.test(url)
  }

  /**
   * éªŒè¯è§†é¢‘åˆ—è¡¨æ˜¯å¦æœ‰æ•ˆ
   */
  static isValidVideoList(videoList: VideoItem[]): boolean {
    if (!Array.isArray(videoList)) {
      return false
    }

    return videoList.every(video => VideoUtils.isValidVideoItem(video))
  }

  /**
   * éªŒè¯å•ä¸ªè§†é¢‘é¡¹æ˜¯å¦æœ‰æ•ˆ
   */
  static isValidVideoItem(video: VideoItem): boolean {
    if (!video || typeof video !== 'object') {
      return false
    }

    // ç›´æ¥è®¿é—®å±æ€§è€Œä¸æ˜¯ä½¿ç”¨ç´¢å¼•è®¿é—®
    return video.id !== undefined && video.id !== null &&
      video.url !== undefined && video.url !== null &&
      video.title !== undefined && video.title !== null &&
      video.description !== undefined && video.description !== null &&
      video.author !== undefined && video.author !== null
  }

  /**
   * æ ¼å¼åŒ–è§†é¢‘æ—¶é•¿
   */
  static formatDuration(seconds: number): string {
    if (!seconds || seconds < 0) {
      return '00:00'
    }

    const hours = Math.floor(seconds / 3600)
    const minutes = Math.floor((seconds % 3600) / 60)
    const secs = Math.floor(seconds % 60)

    if (hours > 0) {
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString()
        .padStart(2, '0')}`
    } else {
      return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
    }
  }

  /**
   * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
   */
  static formatFileSize(bytes: number): string {
    if (!bytes || bytes < 0) {
      return '0 B'
    }

    const units = ['B', 'KB', 'MB', 'GB', 'TB']
    let size = bytes
    let unitIndex = 0

    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024
      unitIndex++
    }

    return `${size.toFixed(1)} ${units[unitIndex]}`
  }

  /**
   * è·å–æ’­æ”¾çŠ¶æ€å¯¹åº”çš„å›¾æ ‡
   */
  static getPlayStateIcon(state: VideoPlayState): string {
    switch (state) {
      case VideoPlayState.PLAYING:
        return 'â¸ï¸'
      case VideoPlayState.PAUSED:
      case VideoPlayState.IDLE:
      case VideoPlayState.FINISHED:
        return 'â–¶ï¸'
      case VideoPlayState.ERROR:
        return 'ğŸ”„'
      case VideoPlayState.LOADING:
        return 'â³'
      default:
        return 'â–¶ï¸'
    }
  }

  /**
   * è·å–æ’­æ”¾çŠ¶æ€å¯¹åº”çš„æè¿°æ–‡æœ¬
   */
  static getPlayStateText(state: VideoPlayState): string {
    switch (state) {
      case VideoPlayState.PLAYING:
        return 'æ’­æ”¾ä¸­'
      case VideoPlayState.PAUSED:
        return 'å·²æš‚åœ'
      case VideoPlayState.IDLE:
        return 'å¾…æ’­æ”¾'
      case VideoPlayState.FINISHED:
        return 'æ’­æ”¾å®Œæˆ'
      case VideoPlayState.ERROR:
        return 'æ’­æ”¾é”™è¯¯'
      case VideoPlayState.LOADING:
        return 'åŠ è½½ä¸­'
      default:
        return 'æœªçŸ¥çŠ¶æ€'
    }
  }

  /**
   * è·å–é”™è¯¯æ¶ˆæ¯
   */
  static getErrorMessage(errorType: string): string {
    const errorMessages = VideoConstants.ERROR_MESSAGES
    switch (errorType) {
      case 'PLAY_FAILED':
        return errorMessages.PLAY_FAILED
      case 'LOAD_FAILED':
        return errorMessages.LOAD_FAILED
      case 'NETWORK_ERROR':
        return errorMessages.NETWORK_ERROR
      case 'RETRY_FAILED':
        return errorMessages.RETRY_FAILED
      case 'UNKNOWN_ERROR':
        return errorMessages.UNKNOWN_ERROR
      default:
        return errorMessages.UNKNOWN_ERROR
    }
  }

  /**
   * è·å–æˆåŠŸæ¶ˆæ¯
   */
  static getSuccessMessage(successType: string): string {
    const successMessages = VideoConstants.SUCCESS_MESSAGES
    switch (successType) {
      case 'PLAY_SUCCESS':
        return successMessages.PLAY_SUCCESS
      case 'LOAD_SUCCESS':
        return successMessages.LOAD_SUCCESS
      default:
        return successMessages.LOAD_SUCCESS
    }
  }

  /**
   * è®¡ç®—è§†é¢‘ç´¢å¼•ï¼ˆæ”¯æŒå¾ªç¯ï¼‰
   */
  static calculateVideoIndex(currentIndex: number, direction: string, totalCount: number): number {
    if (totalCount === 0) {
      return 0
    }

    if (direction === 'next') {
      return currentIndex < totalCount - 1 ? currentIndex + 1 : 0
    } else {
      return currentIndex > 0 ? currentIndex - 1 : totalCount - 1
    }
  }

  /**
   * éªŒè¯è§†é¢‘ç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
   */
  static isValidVideoIndex(index: number, totalCount: number): boolean {
    return index >= 0 && index < totalCount
  }

  /**
   * é˜²æŠ–å‡½æ•°
   */
  static debounce(func: Function, delay: number): Function {
    let timeoutId: number = -1

    return (...args: number[]): void => {
      if (timeoutId !== -1) {
        clearTimeout(timeoutId)
      }
      timeoutId = setTimeout(() => {
        func(...args)
      }, delay) as number
    }
  }

  /**
   * èŠ‚æµå‡½æ•°
   */
  static throttle(func: Function, delay: number): Function {
    let lastCall = 0

    return (...args: number[]): void => {
      const now = Date.now()
      if (now - lastCall >= delay) {
        lastCall = now
        func(...args)
      }
    }
  }

  /**
   * ç”Ÿæˆå”¯ä¸€ID
   */
  static generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2)
  }

  /**
   * æ·±æ‹·è´å¯¹è±¡
   */
  static deepClone(obj: object): object {
    if (obj === null || typeof obj !== 'object') {
      return obj
    }

    if (obj instanceof Date) {
      return new Date(obj.getTime())
    }

    if (obj instanceof Array) {
      const clonedArray: object[] = []
      for (let i = 0; i < obj.length; i++) {
        clonedArray[i] = VideoUtils.deepClone(obj[i])
      }
      return clonedArray
    }

    if (typeof obj === 'object') {
      const clonedObj: Record<string, object> = {}
      const keys = Object.keys(obj)
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i]
        clonedObj[key] = VideoUtils.deepClone(obj[key])
      }
      return clonedObj
    }

    return obj
  }
}
